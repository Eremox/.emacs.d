(ns sicp.core
  (:require [clojure.core.async :as async]))

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))

(def n-times
  (fn[n]
    (if (<= n 1)
      (println "Hello World")
      (do (println "Hello World")
          (recur (dec n))))))

(defn gcd [a b]
  (if (zero? b)
    a
    (recur b (mod a b))))

(defn find-co-prime []
  (let [a (rand-int 2147000000)
        b (rand-int 2147000000)]
    (if (= (gcd a b) 1)
      (vector a b)
      (recur))))


(fn [num lst]
  (for [number lst]
    (for [n (range num)]
      (println number)))
  nil)

(def prn-elems-n-times
  (fn [num lst]
  (if-not (empty? lst)
    (do (dotimes [n num]
          (println (first lst)))
        (recur num (rest lst))))))

(def prn-less-than-delim
  (fn [delim lst]
  (if (first lst)
    (do (if (< (first lst) delim)
          (println (first lst)))
        (recur delim (rest lst))))))

(def filter-odd-nths 
  (fn [lst]
    (loop [n (count lst)
           lst lst]
      (if-not (zero? n)
        (do (if (odd? n) 
              (println (first lst)))
            (recur (dec n) (rest lst)))))))

(def remove-at-odd-nth
  (fn [lst]
    (let [len (count lst)]
      (loop [i 0, lst lst]
        (if (< i len)
          (do (if (odd? i)
                (println (first lst)))
              (recur (inc i) (rest lst))))))))

(def my-range
   (fn [n]
     (loop [i 0, lst []]
       (if (>= i n)
         lst
         (recur (inc i) (conj lst i))))))


(def my-reverse
  (fn [lst]
    (loop [[car & cdr] (seq lst)
           rev '()]
      (if car
        (recur cdr (cons car rev))
        rev))))

(def reduce-odds
  (fn  [lst]
    (loop [acc 0, lst lst]
      (if (first lst)
        (if (odd? (first lst))
          (recur (+ acc (first lst)) (rest lst))
          (recur acc (rest lst)))
        acc))))

(def abs-on-lst
  (fn  [lst]
    (loop [acc [], lst lst]
      (if (first lst)
        (recur (conj acc (-
                          (bit-xor (first lst)
                                   (bit-shift-right (first lst)
                                                    31))
                          (bit-shift-right (first lst)
                                           31)))
               (rest lst))
        acc))))



(defn ! [n]
  (loop [acc 1, n n]
    (if (< n 1)
      acc
      (recur (* acc n) (dec n)))))

(defn give-estimate-e [x n]
  (/ (Math/pow x n)
     (! n)))

(defn estimate-e-to-x [x]
  (loop [estimate 1, n 1]
    (if (<= 20 n)
      estimate
      (recur (+ estimate (give-estimate-e x n)) (inc n)))))

(defn e-fn [x]
  (let [! (fn [n]
            (loop [acc 1, n n]
              (if (< n 1)
                acc
                (recur (* acc n) (dec n)))))
        estimate-e (fn [a n]
                     (/ (Math/pow a n)
                        (! n)))]
    (loop [estimate 1, i 1]
      (if (<= 15 i)
        estimate
        (recur (+ estimate (estimate-e x i)) (inc i))))))


(def states [:modest :happy :merry :enthustiatic])

(defn make-state-handler [states]
  (let [handler (async/chan)]
    (async/go (async/>! handler states))

    (defn get-states []
      (async/go
        (println
         (async/<! handler))))

    (defn add-state [state]
      (async/go
        (let [s (async/<! handler)]
          (async/>! handler (conj s state)))))

    (defn this [opt]
      (cond (= opt 'get-states) get-states
            (= opt 'add-state)  add-state))
    this))
